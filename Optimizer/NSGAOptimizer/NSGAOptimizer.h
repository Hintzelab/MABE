//  MABE is a product of The Hintze Lab @ MSU
//     for general research information:
//         hintzelab.msu.edu
//     for MABE documentation:
//         github.com/Hintzelab/MABE/wiki
//
//  Copyright (c) 2015 Michigan State University. All rights reserved.
//     to view the full license, visit:
//         github.com/Hintzelab/MABE/wiki/License

#pragma once // directive to insure that this .h file is only included one time

#include "../AbstractOptimizer.h"
#include "../../Utilities/MTree.h"

#include <iostream>
#include <numeric>
#include <algorithm>
#include <vector>
#include <memory>
#include <map>

/**
 * NSGA Optimizer - Implementation of NSGA-II based on https://www.iitk.ac.in/kangal/Deb_NSGA-II.pdf
 **/
class NSGAOptimizer : public AbstractOptimizer {
public:

	// Values to optimize for - Parameter Links
	static std::shared_ptr<ParameterLink<std::string>> optimizeFormulasPL;
	static std::shared_ptr<ParameterLink<std::string>> optimizeFormulaNamesPL;
	std::vector<std::shared_ptr<Abstract_MTree>> optimizeFormulasMTs;


	// Scores of current population over time
	std::vector<std::vector<double>> scores;
	std::vector<std::vector<double>> previousScores;
	std::vector<std::vector<double>> combinedScores;
	std::vector<std::string> scoreNames;

	// Parents or peers of current population, scores are logged
	std::vector<std::shared_ptr<Organism>> oldPopulation;

	// Population generated by NSGA-II algorithm
	std::vector<std::shared_ptr<Organism>> newPopulation;

	// Combination of current population (representing offspring) and old population
	std::vector<std::shared_ptr<Organism>> combinedPopulation;

	// Rejected offspring or old organisms which have not been selected for 
	std::vector<std::shared_ptr<Organism>> killPopulation;

	// Parents that are selected after NDS and crowding distance procedures 
	std::vector<std::shared_ptr<Organism>> newParent;

	NSGAOptimizer(std::shared_ptr<ParametersTable> PT_ = nullptr);
	virtual void optimize(std::vector<std::shared_ptr<Organism>> &population) override;
	virtual void cleanup(std::vector<std::shared_ptr<Organism>> &population) override;

	// Fronts of pareto-optimal solutions 
	std::vector<std::vector<int>> paretoFronts;

		// Number of organisms which dominate a given organism
	std::vector<int> dominationCount;
	// Set of organisms which a given organism dominates
	std::vector<std::vector<int>> dominatingSet;

	// Crowding Distance for current and old population
	std::vector<int> currentCrowdingDistance;
	std::vector<int> previousCrowdingDistance;
	std::vector<int> combinedCrowdingDistance;
	std::vector<int> newParentCrowdingDistance;

	std::map<int, int> frontMap; 
  


	// Generate vector of Pareto-optimal fronts from combined population  
	void fastNDS(std::vector<std::shared_ptr<Organism>> &population);

	// Compute crowding distance of current population
	void crowdingDistance(std::vector<std::shared_ptr<Organism>> &population);

  class AbstractSelector {
  public:
    NSGAOptimizer *SO;
    AbstractSelector() = default;
    AbstractSelector(NSGAOptimizer *SO_) : SO(SO_){};
    virtual int select() = 0;
    virtual std::string getType() = 0;
  };

  class TournamentSelector : public AbstractSelector {
  public:
    int tournamentSize;
    TournamentSelector(NSGAOptimizer *SO_)
        : AbstractSelector(SO_) {
      tournamentSize = 1;
    }

    virtual int select() override {
      int winner, challanger;
      winner = Random::getIndex(SO->oldPopulation.size());
      for (int i = 0; i < tournamentSize - 1; i++) {
        challanger = Random::getIndex(SO->oldPopulation.size());
		//std::cout << tournamentSize << " " << i << "  " <<
         //challanger<<"("<<SO->scoresAfterCull[challanger] << "),winner(" <<
         //SO->scoresAfterCull[winner] << ")";
        if (SO->scores[challanger] > SO->scores[winner]) {
			//std::cout << " *";
          winner = challanger;
        }
         //std::cout << std::endl;
      }
      return winner;
    }

	 int crowdingSelect() {
      int winner, challanger;
      winner = Random::getIndex(SO->newParent.size());
      for (int i = 0; i < tournamentSize - 1; i++) {
        challanger = Random::getIndex(SO->newParent.size());
		//std::cout << tournamentSize << " " << i << "  " <<
         //challanger<<"("<<SO->scoresAfterCull[challanger] << "),winner(" <<
         //SO->scoresAfterCull[winner] << ")";
        if (SO->newParentCrowdingDistance[challanger] > SO->newParentCrowdingDistance[winner]) {
			//std::cout << " *";
          winner = challanger;
        }
         //std::cout << std::endl;
      }
      return winner;
    }

    virtual std::string getType() override {
      return (std::string) "Tournament";
    }
  };
};
